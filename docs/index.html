<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>Code Splitting with React and Vite</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="content">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>Code Splitting with React and Vite</h1>
<h3>using import(), React.lazy() and React.Suspense</h3>
<h4>February 2026</h4>
</header>
<nav
  id="content-header"
  aria-labelledby="content-header"
>
  <button type="button" class="previous" disabled>
    <img src="../public/svg/prev.svg" alt="previous" draggable="false">
  </button>
  <span class="previous-name"></span>
  <span class="spacer"></span>
  <button type="button" class="next">
    <img src="../public/svg/next.svg" alt="next" draggable="false">
  </button>
  <span class="next-name"></span>
</nav>

<!-- prerequisites -->
<section id="prerequisites" aria-labelledby="prerequisites" data-item="Prerequisites">
<h2>
<a href="#prerequisites">Prerequisites</a>
</h2>
<p>This tutorial assumes that you are already comfortable with the
basics of React, and that you have already created a number of
interactive apps with a single focus. In particular, I expect you to
know about:</p>
<ul>
<li><a
href="https://react.dev/reference/react/Component">Components</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a></li>
<li><a
href="https://react.dev/learn/passing-data-deeply-with-context">Contexts,
Providers</a> and <a
href="https://react.dev/reference/react/useReducer">Reducers</a></li>
</ul>
<p>If any of these concepts are unfamiliar to you, please follow the
links provided before you continue.</p>
<h2 id="development-environment-and-local-server">Development
environment and local server</h2>
<p>I also assume that you are working with an IDE (Integrated
Development Environment) like VS Code, which allows you to open HTML
files using an extension like Live Server. This means that I can
separate the code you‚Äôll be writing into different files, each with a
single purpose.</p>
<p>You can download these files from <a
href="https://github.com/MERNCraft/Lazy-Loading-Sandbox">here</a>.</p>
</section>
<!-- What is Code Splitting -->
<section id="what-is-code-splitting" aria-labelledby="what-is-code-splitting" data-item="What is Code Splitting?">
<h2>
<a href="#what-is-code-splitting">What is Code Splitting?</a>
</h2>
<p>In a simple React project, the final <code>build</code> process
creates three files:</p>
<ul>
<li>a minified JavaScript file</li>
<li>a compact CSS file</li>
<li>a skeleton <code>index.html</code> file which loads the JavaScript
and CSS files</li>
</ul>
<p>When you open the production version of your app, the
<code>index.html</code> file is downloaded first, and the
<code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags it
contains in its <code>&lt;head&gt;</code> trigger the download of the
JavaScript and CSS files, and the JavaScript file in turn may trigger
the download of various assets.</p>
<p>In other words, there is a one-time flood of data from the server,
and then everything the app needs is available locally. But this flood
can take a significant amount of time.</p>
<p>With code splitting, your build tool creates separate JavaScript and
CSS files for each feature, and only loads those file when they are
explicitly requested. This means that the initial download of data is
minimized, but there may be a delay before a newly-requested feature is
operational, while its files download.</p>
<h2 id="how-does-your-build-tool-know-where-to-split-your-code">How does
your build tool know where to split your code?</h2>
<p>The answer is: you tell your build tool where to split your code by
the way you write it. You indicate where the code should be split with
requests for <code>import()</code>.</p>
<p>Since early 2019, <a
href="https://caniuse.com/?search=import%28%29">all major browsers</a>
support the <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">dynamic
<code>import()</code></a> feature. Dynamic import allows you to load a
module asynchronously at run-time.</p>
<p>During the build process, your build tool will notice every time you
use the <code>import()</code> syntax, and will bundle each block of
imported code into its own JavaScript and CSS files. The main JS file
that is requested by the <code>index.html</code> file will contain the
relative URLs of each of these feature bundles, so it can
<code>import()</code> them whenever they are needed.</p>
<h2 id="the-challenges">The challenges</h2>
<p>Imagine this scenario: you click on a link to an activity which
downloads a feature bundle. Let‚Äôs call this Activity A. You start
working with Activity A, and then you switch to a different activity.
When you come back to Activity A later, you find that all the changes
you have made have been forgotten, and you are back to where the
activity started.</p>
<p>When you navigate away from an activity, your browser dismounts the
components associated with it, and all the state associated with those
components is lost. One solution is to keep the state for the activity
in a Context which does not get dismounted. If you do that, you can
restore the component state from the Context when the activity is
remounted later.</p>
<p>If the Context only contains state for Activity A, then it would make
sense to import it at the same time as the components for Activity A,
but then you have to insert the Context‚Äôs Provider into your app‚Äôs
component hierarchy, as a parent or ancestor of the activity
components.</p>
<p>If you later add a new activity (Activity B) that needs to store some
of the same state as Activity A, you might need to place the shared
Provider higher up the component hierarchy, so that it can make the
Context available to both activities.</p>
<h2 id="building-a-code-splitting-app-step-by-step">Building a
code-splitting app, step by step</h2>
<p>I plan to show, step-by-step, how code splitting works in a React
frontend. I‚Äôll show you how to build an app where you can simply create
a new directory in your development environment that contains all the
code and assets that you need for a new activity, so that the new
version of the deployed app will be able to load the activity on the
fly. I‚Äôll show you how to ensure that each activity maintains its state
if you navigate to a different activity and back.</p>
</section>
<!-- Installing the Work Files -->
<section id="installing-the-work-files" aria-labelledby="installing-the-work-files" data-item="Installing the Work Files">
<h2>
<a href="#installing-the-work-files">Installing the Work Files</a>
</h2>
<p>Eventually, I‚Äôll show you how to build a demo app using <a
href="https://en.wikipedia.org/wiki/Npm">npm</a> and <a
href="https://vite.dev/">Vite</a> to provide a sturdy development
framework. But for now, you can use something more lightweight.</p>
<p>Browsers cannot understand the JSX syntax that React uses, so your
React code has to be compiled to plain JavaScript before it is deployed
to a server. Vite provides all the tools you need to compile your code
and create a production-ready app. For this tutorial, though, you can
use <a href="https://esbuild.github.io/">esbuild</a> to take care of
compilation. Vite is built on top of esbuild, so the JavaScript output
will be the same. You‚Äôll just have to provide your own local server to
host the files you create.</p>
<h2 id="preparing-a-workspace">Preparing a workspace</h2>
<p>Clone or download the files in this repository: <a
href="https://github.com/MERNCraft/Lazy-Loading-Sandbox">Lazy-Loading
Sandbox</a>.</p>
<p>Open your IDE and a Terminal window inside the Sandbox directory. You
should see a folder hierarchy like this:</p>
<pre class="line-numbers"><code class="line-numbers">.
‚îú‚îÄ‚îÄ 01
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ 02
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ .../
‚îú‚îÄ‚îÄ build.mjs
‚îú‚îÄ‚îÄ buildAll.mjs
‚îú‚îÄ‚îÄ cleanUp.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md</code></pre>
<p>Each numbered folder contains a mini-app for you to practise with,
but these have to be compiled to JavaScript before you can open them in
your browser.</p>
<h2 id="installing-node-modules">Installing node modules</h2>
<p>In the Terminal run this command:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i esbuild react react-dom</code></pre>
<p>You should see a new folder appear in your Sandbox directory:</p>
<pre class="line-numbers"><code class="line-numbers">‚îÜ
‚îú‚îÄ‚îÄ node_modules
‚îÇ   ‚îú‚îÄ‚îÄ @esbuild
‚îÇ   ‚îú‚îÄ‚îÄ esbuild
‚îÇ   ‚îú‚îÄ‚îÄ react
‚îÇ   ‚îú‚îÄ‚îÄ react-dom
‚îÇ   ‚îî‚îÄ‚îÄ scheduler
‚îÜ</code></pre>
<p>I assume that you are used to seeing <code>react</code>,
<code>react-dom</code> and <code>scheduler</code> in your dependencies.
The <code>esbuild</code> module is the one which will compile your React
code to JavaScript and perform code splitting for you.</p>
<h2 id="building-all-the-mini-apps-at-once">Building all the mini-apps
at once</h2>
<p>Each mini-app is contained in a numbered folder. To minimize the
download size, none of the mini-apps have been built for deployment. To
do this, run the following command in your Terminal:</p>
<p><code>node buildAll.mjs</code></p>
<p>This will tell the buildAll.mjs script to create an
<code>assets/</code> subfolder inside each of the numbered folders. This
will look something like this, but the exact names of the files may be
different:</p>
<pre class="line-numbers"><code class="line-numbers">.
‚îú‚îÄ‚îÄ 01
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js.map
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chunk-UASCOLGB.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chunk-UASCOLGB.js.map
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LazyComponent-C4ZJBLUW.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent-C4ZJBLUW.js.map
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ .../
‚îú‚îÄ‚îÄ launch.mjs
‚îú‚îÄ‚îÄ buildAll.mjs
‚îú‚îÄ‚îÄ cleanUp.js
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md</code></pre>
<h2 id="opening-a-mini-app-in-your-browser">Opening a mini-app in your
browser</h2>
<p>Use your local server to open the <code>index.html</code> file in any
of the numbered folders. If you are working with VS Code, this is how
you do this:</p>
<figure>
<img src="images/live-server.webp"
alt="Opening an HTML file with Live Server in VS Code" />
<figcaption aria-hidden="true">Opening an HTML file with Live Server in
VS Code</figcaption>
</figure>
<p>The file should open in your browser:</p>
<figure>
<img src="images/01-index.webp"
alt="You can inspect the React code in the browser‚Äôs Debugger" />
<figcaption aria-hidden="true">You can inspect the React code in the
browser‚Äôs Debugger</figcaption>
</figure>
<details class="alert" open>
<summary>
Double-click doesn‚Äôt work
</summary>
<p><strong>You must use a local server to open the
<code>index.html</code> files.</strong></p>
<p>If you simply double-click on a mini-app <code>index.html</code> file
on your desktop, it <em>will</em> open in your browser, but, for your
safety, the browser will refuse to load any files via the
<code>import()</code> command, so none of the code splitting features
will work.</p>
<figure>
<img src="images/01-file.webp"
alt="import() is not supported for URLs with the file:/// protocol" />
<figcaption aria-hidden="true">import() is not supported for URLs with
the <code>file:///</code> protocol</figcaption>
</figure>
</details>
</section>
<!-- The Simplest Split -->
<section id="the-simplest-split" aria-labelledby="the-simplest-split" data-item="The Simplest Split">
<h2>
<a href="#the-simplest-split">The Simplest Split</a>
</h2>
<p>In the Sandbox folder that you created in the
<a href="#installing-the-work-files">last step</a>, take a look at the
files at the root of the <code>01/</code> folder:</p>
<h2 id="index.html">index.html</h2>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Code Splitting <b>01</b>&lt;/title&gt;
  &lt;!-- The build step guarantees this is a valid link --&gt;
  <b>&lt;script defer type="module" src="./assets/App.js"&gt;&lt;/script&gt;</b>
&lt;/head&gt;
&lt;body&gt;
  <b>&lt;div id="root"&gt;&lt;/div&gt;</b>
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>This is a generic HTML file, which is identical in every numbered
folder, except that the title changes to match the folder name:</p>
<pre class="language-html line-numbers" data-start="5"><code class="language-html line-numbers">  <i>&lt;title&gt;Code Splitting </i><b>01</b><i>&lt;/title&gt;</i></code></pre>
<p>It simply defines‚Ä¶</p>
<pre class="language-html line-numbers" data-start="10"><code class="language-html line-numbers">&lt;div id="root"&gt;&lt;/div&gt;</code></pre>
<p>‚Ä¶ which React will use as the container for all the DOM elements that
it generates, and it loads the <code>App.js</code> script from the
<code>assets/</code> folder, which was created by the
<code>esbuild</code> when you ran <code>node buildAll.mjs</code>.</p>
<pre class="language-html line-numbers" data-start="7"><code class="language-html line-numbers">  &lt;script defer type="module" src="./assets/App.js"&gt;&lt;/script&gt;</code></pre>
<h2 id="app.jsx">App.jsx</h2>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import { Suspense, lazy } from 'react';
import { createRoot } from 'react-dom/client';

const LazyComponent = lazy(() =&gt; import('./LazyComponent.jsx'))

function App() {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;LazyComponent /&gt;
    &lt;/Suspense&gt;
  );
}

createRoot(document.getElementById('root')).render(&lt;App /&gt;);</code></pre>
<p>The <code>App.jsx</code> file implements many powerful concepts that
I‚Äôll explain in the following sections. In short, it uses‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="4"><code class="language-javascript line-numbers"><b>import</b>('./LazyComponent.jsx')</code></pre>
<p>‚Ä¶ to load the <code>LazyComponent.jsx</code> file asynchronously at
run time, and it uses <code>lazy()</code> and
<code>&lt;Suspense&gt;</code> to handle this import elegantly for React.
More about this later.</p>
<h2 id="lazycomponent.jsx">LazyComponent.jsx</h2>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function LazyComponent() {
  return &lt;h1&gt;I am lazy.&lt;/h1&gt;;
}</code></pre>
<p><code>LazyComponent.jsx</code> is an ultra-simple component function,
which shows the text <code>"I am lazy."</code> as a header.</p>
<p><strong>Note that the <code>LazyComponent()</code> function is
explicitly exported as the <code>default</code>. This makes it easier
for the <code>React.lazy</code>, which expects the dynamically imported
module to provide a <code>default</code> export.</strong> You‚Äôll see how
to deal with named exports later.</p>
<h2 id="assets">assets/</h2>
<p>The <code>assets/</code> folder, which was created by the build
process, contains 6 files.</p>
<p>The random-looking last eight letters in a file‚Äôs name are a hash of
its contents. The name will stay the same, so long as the contents do
not change. This means that the browser can safely cache the file,
knowing that when a file with an identical name is requested, its
contents will be identical. This means it it is safe to use its cached
copy instead of triggering a new download.</p>
<p>However, if the contents of any file have changed since I wrote this
tutorial, then the hashes that you see will be different.</p>
<pre class="line-numbers"><code class="line-numbers">01
‚îú‚îÄ‚îÄ App.jsx
‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îú‚îÄ‚îÄ App.js
‚îÇ   ‚îú‚îÄ‚îÄ App.js.map
‚îÇ   ‚îú‚îÄ‚îÄ chunk-U3XB4E5Q.js
‚îÇ   ‚îú‚îÄ‚îÄ chunk-U3XB4E5Q.js.map
‚îÇ   ‚îú‚îÄ‚îÄ LazyComponent-27PLPFAM.js
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent-27PLPFAM.js.map
‚îú‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ LazyComponent.jsx</code></pre>
<h3 id="the-.map-files">The <code>.map</code> files</h3>
<p>The files with the extension <code>.map</code> are not required for
your code to run. They are used by the browser to make it easier for you
to use the Debugger. Thanks to the <code>.map</code> files, you can step
through your original JSX code, and the browser will follow your steps
through the compiled JavaScript code behind the scenes for you.</p>
<figure>
<img src="images/01-mapped.webp"
alt="Inspecting the original JSX code in the browser Debugger" />
<figcaption aria-hidden="true">Inspecting the original JSX code in the
browser Debugger</figcaption>
</figure>
<p>Without the <code>.map</code> files, the JSX code will not be
available, and all the browser can show you is the compiled JavaScript
code, which you didn‚Äôt write and which is much more complex to
follow.</p>
<figure>
<img src="images/01-mapless.webp"
alt="Without the .map files, the browser Debugger is harder to use" />
<figcaption aria-hidden="true">Without the .map files, the browser
Debugger is harder to use</figcaption>
</figure>
<h3 id="app.js">App.js</h3>
<p><code>App.js</code> is a pure JavaScript file, and it is huge. It
contains all the code that React wants to use at runtime, and which
<code>esbuild</code> chose not to place in the
<code>chunk-XXXXXXXX.js</code>, in addition to the compiled version of
the original <code>App.jsx</code> file.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import {
  __commonJS,
  __toESM,
  require_jsx_runtime,
  require_react
} from "./chunk-U3XB4E5Q.js";</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">// Over 20000 lines skipped, then the code compiled from App.jsx... //</code></pre>
<pre class="language-javascript line-numbers" data-start="20448"><code class="language-javascript line-numbers">// 01/App.jsx
var require_App = __commonJS({
  "01/App.jsx"() {
    var import_react = __toESM(require_react());
    var import_client = __toESM(require_client());
    var import_jsx_runtime = __toESM(require_jsx_runtime());
    var LazyComponent = (0, import_react.lazy)(() =&gt; import("./LazyComponent-27PLPFAM.js"));
    function App() {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: "Loading..." }), children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LazyComponent, {}) });
    }
    (0, import_client.createRoot)(document.getElementById("root")).render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, {}));
  }
});
export default require_App();</code></pre>
<h3 id="chunk-xxxxxxxx.js">chunk-XXXXXXXX.js</h3>
<p>The file whose name begins <code>chunk-</code> and which has the
extension <code>.js</code> contains code that <code>esbuild</code> chose
share between multiple modules.</p>
<p>It only exists because the <code>App.jsx</code> code contains
<code>import()</code>, and because the <code>App.jsx</code> file and the
<code>LazyComponent.jsx</code> file both need access to the same React
functions.</p>
<p>It, too, is a fairly big file, and it would be even bigger if your
split modules had more code in common.</p>
<p>It will be downloaded when the browser is executing
<code>App.js</code> and encounters a static import from
<code>chunk-XXXXXXXX.js</code>, as a dependency.</p>
<h3 id="lazycomponent-xxxxxxxx.js">LazyComponent-XXXXXXXX.js</h3>
<p>LazyComponent has been given its own file, because it is loaded by
the <code>import()</code> command. It is a fairly small file, because
all the React features it requires have already been included in
<code>App.js</code> or <code>chunk-XXXXXXXX.js</code>. React runtime
helpers have been placed in the shared chunk, while App.js contains
application glue code.</p>
<p>Its contents are a pure JavaScript version of
<code>LazyComponent.jsx</code>.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import {
  __esm,
  __toESM,
  require_jsx_runtime
} from "./chunk-U3XB4E5Q.js";

// 01/LazyComponent.jsx
function LazyComponent() {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", { children: "I am lazy." });
}
var import_jsx_runtime;
var init_LazyComponent = __esm({
  "01/LazyComponent.jsx"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
  }
});
init_LazyComponent();
export {
  LazyComponent as default
};
//# sourceMappingURL=LazyComponent-27PLPFAM.js.map</code></pre>
<details class="note" open>
<summary>
The weight of React
</summary>
<p>Take a moment to compare the size of the raw App.jsx file and the
size of the JavaScript bundle that now includes your code and its
dependencies. <code>App.js</code> is around 3000 times larger than
<code>App.jsx</code>.</p>
<p>But I said that the whole purpose of this tutorial was to show you
how to reduce the size of the initial download, didn‚Äôt I?</p>
<p>No worries. Most of this size increase does not come from your code,
but from bundling React and ReactDOM into the same file.</p>
<figure>
<img src="images/compiled-size.webp"
alt="Comparing the compiled file with the raw JSX" />
<figcaption aria-hidden="true">Comparing the compiled file with the raw
JSX</figcaption>
</figure>
<p>To be fair, at this point, <code>esbuild</code> is transpiling the
JSX for development purposes, so it is generating unminified JavaScript
and helpers that are useful during dev-time debugging.</p>
<p>There are ways to reduce the amount of production code that your
server will deploy for the Internet, using minification and
tree-shaking, but this tutorial is not the place to discuss that.</p>
<p>The arguments for using React are:</p>
<ol type="1">
<li><p><strong>Productivity now</strong></p>
<p>You‚Äôll complete your projects faster with the tools that React
provides.</p></li>
<li><p><strong>Real-world context</strong></p>
<p>The production-ready projects that you will be working on are far
more complex than what is covered by this tutorial</p></li>
<li><p><strong>Future-proofing</strong></p>
<p>Unused power today is likely to be used later. The actual project
that I am creating will eventually contain activities that have not even
been thought of yet. React gives me room to expand.</p></li>
</ol>
<p>However, if you have just a small project that you know is never
going to grow big, it might be worthwhile writing it in plain
JavaScript.</p>
</details>
</details>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>In summary, <code>esbuild</code> has split the code of this mini-app
into three files:</p>
<ol type="1">
<li>The entry-point bundle for App.jsx, with all the code for running
the pure JavaScript version of App.jsx</li>
<li>Code shared between the compiled versions of App.jsx and
LazyComponent.jsx</li>
<li>The code specific to each module that is loaded with the
<code>import()</code> command. (In this case, there is only one such
module).</li>
</ol>
<p>For each of these three files, <code>esbuild</code> has also created
a file with a <code>.map</code> extension, to help you when you are
stepping through or debugging your JSX code.</p>
<h2 id="import-lazy-and-suspense">import(), lazy() and Suspense</h2>
<p>In the next sections, you can explore how <code>import()</code>,
<code>lazy()</code> and <code>Suspense</code> work, separately and
together.</p>
<p>The <code>import()</code> command is native JavaScript.
<code>Suspense</code> and <code>lazy()</code> are React-specific
features, designed to handle the asynchronous nature of
<code>import()</code> cleanly in a React environment.</p>
</details>
</section>
<!-- Dynamic import() -->
<section id="dynamic-import" aria-labelledby="dynamic-import" data-item="Dynamic import()">
<h2>
<a href="#dynamic-import">Dynamic import()</a>
</h2>
<p>The <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"><code>import()</code>
command</a> is native JavaScript. You can use it completely
independently of React. Its purpose is to request a JavaScript module by
URL, downloading it if it has not already been loaded, and to return a
<a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
This Promise should resolve to the usable contents of the file if the
download is successful.</p>
<h2 id="proof-of-concept">Proof of concept</h2>
<p>Here‚Äôs a very simple demo of dynamic <code>import()</code> at work.
You can create your own scripts similar to the ones listed below, or you
can open the <code>03_import_demo</code> subfolder in your
<code>Sandbox/</code> folder.</p>
<p>In either case, you‚Äôll need to open the <code>index.html</code> file
with your local server, for the reasons explained
<button data-name="anchor-opening-a-mini-app-in-your-browser">here</button>.</p>
<h3 id="index.html-1">index.html</h3>
<p>A simple HTML file with a button and a <code>&lt;div&gt;</code> with
the <code>id</code> ‚Äúgame-space‚Äù, which is where an imported module will
appear after the button is clicked.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Import() Demo&lt;/title&gt;
  &lt;script defer src="script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id="button"&gt;
    Import Placeholder Module
  &lt;/button&gt;
  &lt;div id="game-space"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 name="anchor-import-placeholder">
script.js
</h3>
<p>The JavaScript file that is loaded directly by
<code>index.html</code>. I‚Äôll describe how it works shortly.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">const button = document.getElementById("button")
const gameSpace = document.getElementById("game-space")

button.addEventListener("click", importGame)

function importGame() {
  const url = `./placeholder.js`
  const promise = import(url)
  promise
    .then(result =&gt; {
      console.log("result:", result)
      return result.default
    })
    .then(renderGame =&gt; renderGame(gameSpace))
    .catch(error =&gt; console.error(error))
}</code></pre>
<h3 id="placeholder.js">placeholder.js</h3>
<p>The external JavaScript file which will be imported by a click on the
button. It does nothing special. It simply indicates its presence by
adding some text to the <code>#game-space</code> div, a pointer to which
is passed to it by the <code>root</code> argument.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function (root) {
  root.textContent = "üéâ Placeholder module loaded!";
}

console.log("Placeholder module evaluated")</code></pre>
<h2 id="testing-this-proof-of-concept">Testing this proof of
concept</h2>
<p>Launch <code>index.html</code> with your local server. You should see
a button:</p>
<figure>
<img src="images/03-placeholder-button.webp"
alt="Before the Import Placeholder Module button is pressed" />
<figcaption aria-hidden="true">Before the Import Placeholder Module
button is pressed</figcaption>
</figure>
<p>Click on the button. You should see that the function from
placeholder.js has been called and the <code>textContent</code> of the
<code>#game-space</code> div has been set.</p>
<figure>
<img src="images/03-placeholder-loaded.webp"
alt="After the Placeholder Module button is loaded" />
<figcaption aria-hidden="true">After the Placeholder Module button is
loaded</figcaption>
</figure>
<h2 id="modules-and-json-imports">Modules and JSON imports</h2>
<p>You can use the <code>import</code> keyword to load either functional
code from a <code>.js</code> file or data from a <code>.json</code>
file. I‚Äôll explain how to import JSON data later.</p>
<p>A JavaScript file that is loaded using import is called a
<code>module</code>. A module exports one or more objects. These objects
may be functions, plain old JavaScript objects (POJOs) created with
<code>{}</code> curly brackets, or arrays. A module can export one
object as <code>default</code>. Any other object it exports must have a
name. The example you have just tested uses an anonymous function
exported as <code>default</code>. You‚Äôll see other possibilities later
in the tutorial.</p>
<details class="note" open>
<summary>
<code>import</code> vs <code>require</code>
</summary>
<p>You may have used the <code>require</code> keyword in Node projects.
This has a similar, but not identical, function, and browsers do not
support <code>require</code>. In particular, <code>require()</code> is
synchronous. Node.js stops executing the current script while it loads
the required file and executes <em>it</em>. This is fine when the
required file is stored locally on the server and can be loaded
fast.</p>
<p>In a browser, it can take some time before a file is downloaded, so
<code>import</code> works asynchronously, and returns a <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
This <code>Promise</code> needs to be resolved before it can be
used.</p>
</details>
<h2 id="understanding-function-importgame">Understanding function
importGame()</h2>
<p>This is the code which is executed when you click on the Import
Placeholder Module button:</p>
<pre class="language-javascript line-numbers" data-start="7"><code class="language-javascript line-numbers">  const url = `./placeholder.js`
  const promise = import(url)
  promise
    .then(result =&gt; {
      console.log("result:", result)
      return result.default
    })
    .then(renderGame =&gt; renderGame(gameSpace))
    .catch(error =&gt; console.error(error))</code></pre>
<p>Things to notice:</p>
<ol type="1">
<li><p>The path to the file to import is given by a URL. This can be
relative to the location of the page that calls it (as in the case
above), or it can be an absolute URL to a file on some other
server.</p></li>
<li><p>The <code>import()</code> call returns a promise. When this
resolves, the <code>.then()</code> function logs it to the console, so
that you can see that the resolved value is an object with a property
<code>default</code>, whose value is the anonymous function from
<code>placeholder.js</code>, which has now been given a name:
<code>default</code>.</p>
<pre class="console line-numbers"><code class="console line-numbers">Object {
  default: function default(root)
  Symbol(Symbol.toStringTag): "Module"
}</code></pre></li>
</ol>
<p>In addition there is a Symbol with the value ‚ÄúModule‚Äù. This symbol
indicates that the object represents an ES module. All ES modules are
automatically executed in <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">‚Äústrict
mode‚Äù</a>. This means that you will see more meaningful errors, and the
browser can perform certain optimizations which are not available in
JavaScript‚Äôs default <a
href="https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode">‚Äúsloppy‚Äù
mode</a>.</p>
<ol start="3" type="1">
<li><p>I‚Äôve explicitly used a Promise here, rather than the sweeter
<code>async/await</code> syntax that you might already know. This is
simply to underline the fact that the output of <code>import()</code> is
a Promise which must be resolved before the imported module can be
used.</p></li>
<li><p>Line 14 then receives this <code>default</code> function and
renames it to <code>renderGame</code> and then executes it. Which is how
the <code>textContent</code> of the <code>#game-space</code> div got
set.</p></li>
</ol>
<h2 id="multiple-import-calls-only-one-download">Multiple import()
calls, only one download</h2>
<p>You may already have noticed evidence that the
<code>placeholder.js</code> file is only downloaded once. If you open
the Console tab of your Developer Tools, you should see that the
line‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="5"><code class="language-javascript line-numbers">console.log("Placeholder module evaluated")</code></pre>
<p>‚Ä¶ logs only one message in the Console, even if you click on the
Import Placeholder Module multiple times.</p>
<figure>
<img src="images/03-single-download.webp"
alt="‚ÄúPlaceholder module evaluated‚Äù is logged to the console only once" />
<figcaption aria-hidden="true">‚ÄúPlaceholder module evaluated‚Äù is logged
to the console only once</figcaption>
</figure>
<p>Once the browser has downloaded the file and evaluated it, it will
not ask for it again, even if you disable the browser cache.</p>
<figure>
<img src="images/03-downloaded-once.webp"
alt="The Network tab only shows one download, even when caching is disabled" />
<figcaption aria-hidden="true">The Network tab only shows one download,
even when caching is disabled</figcaption>
</figure>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>The points to note here are:</p>
<ul>
<li><code>import()</code> returns a Promise which must be resolved
before the imported module can be used</li>
<li>The imported module is evaluated once and for all</li>
<li>The imported data is an object with a <code>default</code> property
that allows you to access the module.</li>
</ul>
<p>Now that you understand how <code>import()</code> can load a module
dynamically, let‚Äôs see how to make the imported module interactive. In
the next section, you‚Äôll work with a tiny game that you can actually
play.</p>
</details>
</section>
<!-- A Simplistic Game -->
<section id="a-simplistic-game" aria-labelledby="a-simplistic-game" data-item="A Simplistic Game">
<h2>
<a href="#a-simplistic-game">A Simplistic Game</a>
</h2>
<p>The <button data-name="anchor-import-placeholder">proof of concept
code in the last section</button> does not create anything interactive.
You can change the content of <code>placeholder.js</code> to what is
shown below, or open the <code>04_import_number_game/</code> subfolder
in your <code>Sandbox/</code> folder, where you will find the same
code.</p>
<h3 name="anchor-number-game">
Edited placeholder.js
</h3>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function renderGame(root) {
  root.innerHTML = ""

  const target = Math.ceil(Math.random() * 5)

  const checkNumber = (event) =&gt; {
    const button = event.target
    if (button.textContent == target) {
      button.style.background = "green"
      button.style.color = "white"
      
    } else {
      button.disabled = true
    }
  }

  const title = document.createElement("h2")
  title.textContent = `Click number ${target}`
  root.append(title)


  for (let i = 1; i &lt;= 5; i++) {
    const button = document.createElement("button")
    button.textContent = i
    button.style.margin = "0.5em"

    button.onclick = checkNumber

    root.append(button)
  }
}</code></pre>
<p>This creates a simple, yet functional game that demonstrates the
basics of user interaction:</p>
<figure>
<img src="images/04-number-game.webp"
alt="Importing an interactive mini-game" />
<figcaption aria-hidden="true">Importing an interactive
mini-game</figcaption>
</figure>
<details class="hint" open>
<summary>
A React version of the same game
</summary>
<p>Compare the plain JavaScript code above to how it would look when
written in JSX for React:</p>
<h3 id="placeholder.jsx">Placeholder.jsx</h3>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">const RenderGame = () =&gt; {

  const target = Math.ceil(Math.random() * 5)

   const checkNumber = (event) =&gt; {
    const button = event.target
    if (button.textContent == target) {
      button.style.background = "green"
      button.style.color = "white"
      
    } else {
      button.disabled = true
    }
  }

  const title = &lt;h2&gt;Click number {target}&lt;/h2&gt;

  const buttons = [1,2,3,4,5].map( number =&gt; (
    &lt;button
      key={number}
      onClick={checkNumber}
      style={{
        margin: "0.5em"
      }}
    &gt;
      {number}
    &lt;/button&gt;
  ))

  return (
    &lt;&gt;
      { title }
      { buttons }   
    &lt;/&gt;
  )
}

ReactDOM
  .createRoot(document.getElementById("root"))
  .render(&lt;RenderGame /&gt;)</code></pre>
<p>You can test this JSX version by launching the
<code>JSindeX.html</code> file that you‚Äôll find in the same
<code>Sandbox/04-import-number-game/</code> folder.</p>
<p>Do you see how the plain vanilla JavaScript performs an identical
function to the JSX code?</p>
<p>Only the line‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="2"><code class="language-javascript line-numbers">  root.innerHTML = ""</code></pre>
<p>‚Ä¶ has no equivalent in the JSX code, because the JSX code is not
imported.</p>
<h3 id="a-peek-behind-the-curtain">A peek behind the curtain</h3>
<p>The <code>JSindeX.html</code> file uses <code>&lt;script&gt;</code>
tags in the <code>&lt;head&gt;</code> to download the code for React and
ReactDOM from a CDN, and also downloads a Babel standalone that
transpiles the JSX code in <code>Placeholder.jsx</code> to plain
JavaScript directly in the browser.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;JSX Number Game&lt;/title&gt;

  &lt;!-- Load React and ReactDOM from CDN --&gt;
  <b>&lt;script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"&gt;&lt;/script&gt;</b>
  &lt;!-- Load Babel standalone to convert JSX to JS --&gt;
  <b>&lt;script src="https://unpkg.com/@babel/standalone@7.21.4/babel.min.js"&gt;&lt;/script&gt;</b>

  &lt;!-- Load the custom script that creates the React components --&gt;
    &lt;script defer <b>type="text/babel"</b> src="./Placeholder.jsx"&gt;&lt;/script&gt;
  
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="root"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>NOTE: Using the Babel standalone is fine for a quick and
dirty demo, like this one, but it won‚Äôt allow you to use
<code>import</code> in any shape or form. This is why you need to use
<code>esbuild</code> to precompile the JSX code elsewhere in this
tutorial.</strong></p>
</details>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>This section has shown you that plain JavaScript can do everything
that React‚Äôs JSX code can do. Indeed, this should go without saying,
because JSX transpiles down to JavaScript for production.</p>
<p>The way you write code in modular components in React is made
possible by the native JavaScript keyword, <code>import</code>.</p>
<p>In the next section, you‚Äôll see JavaScript versions of the three
mini-language game modules that make up the final React project, which
you already saw as a preview at the beginning.</p>
</details>
</section>
<!-- Three Language Games -->
<section id="three-language-games" aria-labelledby="three-language-games" data-item="Three Language Games">
<h2>
<a href="#three-language-games">Three Language Games</a>
</h2>
<p>In the folder <code>Sandbox/05_three_games/</code> you can find the
<code>index.html</code> file and open it with your local server. You
should see a page with three buttons, with the names of the games, and a
grey array, where the games will appear.</p>
<figure>
<img src="images/05-three-games.webp"
alt="The Three Games web app, with none of the games loaded" />
<figcaption aria-hidden="true">The Three Games web app, with none of the
games loaded</figcaption>
</figure>
<p>You can click on each button in turn, to see the game that the app
imports and displays:</p>
<figure>
<img src="images/05-odd-one-out.webp"
alt="Which word is the odd one out?" />
<figcaption aria-hidden="true">Which word is the odd one
out?</figcaption>
</figure>
<figure>
<img src="images/05-choose-picture.webp"
alt="Which picture matches the word?" />
<figcaption aria-hidden="true">Which picture matches the
word?</figcaption>
</figure>
<figure>
<img src="images/05-choose-word.webp"
alt="Which word matches the picture?" />
<figcaption aria-hidden="true">Which word matches the
picture?</figcaption>
</figure>
<h2 id="the-container-app">The container app</h2>
<h3 id="index.html-2">index.html</h3>
<p>The <code>index.html</code> file is deliberately boring: three
buttons, one mount point, no framework.</p>
<p>If it helps, you can think of this as the non-React equivalent of a
root component with three event triggers and one render target.</p>
<details class="tldr">
<summary>
So bore me with it
</summary>
<p>The <code>index.html</code> file loads a basic stylesheet (which I
won‚Äôt treat here) and a plain JavaScript file (which I describe
below).</p>
<p>It creates three buttons and a <code>&lt;div&gt;</code> with the
<code>id</code> <code>game-space</code> (the grey area), and wraps these
in a <code>&lt;main&gt;</code> tag. Nothing complex.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Three Games&lt;/title&gt;
  &lt;link rel="stylesheet" href="styles.css"&gt;
  <b>&lt;script defer src="script.js"&gt;&lt;/script&gt;</b>
&lt;/head&gt;
&lt;body&gt;
  &lt;main&gt;
    &lt;div id="buttons"&gt;
      &lt;<b>button</b> type="button" id="difference-game"&gt;
        Odd One Out
      &lt;/button&gt;
      &lt;<b>button</b> type="button" id="picture-game"&gt;
          Picture Game
      &lt;/button&gt;
      &lt;<b>button</b> type="button" id="word-game"&gt;
        Word Game
      &lt;/button&gt;
    &lt;/div&gt;
    <b>&lt;div id="game-space"&gt;&lt;/div&gt;</b>
  &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</details>
<h3 id="script.js">script.js</h3>
<p>The <code>script.js</code> file is almost identical to the
<button data-name="anchor-import-placeholder">ones you‚Äôve already
seen</button>. The only major differences are that this time:</p>
<ol type="1">
<li>There are three buttons which are given the same event listener</li>
<li>The <code>url</code> of the module that is loaded is obtained using
the <code>id</code> of the button that was clicked.</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">const buttons = document.<b>getElementsByTagName</b>("button")
const gameSpace = document.getElementById("game-space")

<b>Array.from(buttons).forEach( button =&gt; {</b>
  button.addEventListener("click", importGame)
<b>})</b>

function importGame(<b>event</b>) {
  <b>const gameName = event.target.id
  const url = `./games/${gameName}.js`</b>
  const promise = import(url)
  promise
    .then(result =&gt; result.default)
    .then(renderGame =&gt; renderGame(gameSpace))
    .catch(error =&gt; console.error(error))
}</code></pre>
<p>As you will see later, this is the same pattern that
<code>React.lazy()</code> uses internally: a user action triggers a
dynamic import, which resolves to a render function.</p>
<h2 id="the-three-games">The three games</h2>
<p>The first game (Odd One Out) is clearly different from the other two.
It has no images and it uses a different set of words.</p>
<p>The other two games (Picture Game and Word Game) have a lot in
common. Although each has its own specific game logic, they share:</p>
<ul>
<li>the same word list</li>
<li>the same images</li>
<li>the same basic styling and layout</li>
<li>the method for checking if the player got the right answer.</li>
</ul>
<p>It would make sense for them to import these shared features from the
same modules. These modules would be loaded and evaluated once, when the
first of the two games is imported, and then be already available when
the second game is opened.</p>
<h2 id="making-work-for-you">Making work for you</h2>
<p>But this is a tutorial, so I have deliberately coded them
differently, to give you some work to do.</p>
<p>You can imagine that each of these files was written by a different
member of your Dev Team, after an initial discussion about the use of
modules. Each member of the team has understood the concept slightly
differently.</p>
<p>If you can apply the same elegant modular to each of these
mini-games, then you will have shown how much you have understood so
far.</p>
<p>But first you need to know what you have to work on.</p>
<h2 id="picture-game.js-a-standalone-approach">picture-game.js: a
standalone approach</h2>
<p>I won‚Äôt show all the code in
<code>Sandbox/05-three-games/games/picture-game.js</code> here, because
you can have the file itself that you can look at. You don‚Äôt need to
understand the whole file. Just notice how many different
responsibilities it has.</p>
<p>Here‚Äôs what to look out for:</p>
<ul>
<li>Everything lives in one file</li>
<li>Styles, data, logic are bundled</li>
<li>The module exports a single render function</li>
</ul>
<details class="tldr">
<summary>
A closer look
</summary>
<p>You‚Äôll find that the file at
<code>Sandbox/05-three-games/games/picture-game.js</code> is organized
in a similar way to the <button data-name="anchor-number-game">Number
Game</button> from the last section:</p>
<ol type="1">
<li><p>Everything is included in one file.</p></li>
<li><p>The data used by the game is defined inside the file itself:</p>
<pre class="language-javascript line-numbers" data-start="6"><code class="language-javascript line-numbers">const words = [
  "ball",
  "bear",
  "bell",
  "boar",
  "fair",
  "fall",
  "fell",
  "four"
]</code></pre></li>
<li><p>There are helper functions to control the logic of the game, such
as:</p>
<pre class="language-javascript line-numbers" data-start="92"><code class="language-javascript line-numbers">const checkClick = ( target, word, button, div ) =&gt; {</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">// 9 lines skipped</code></pre>
<pre class="language-javascript line-numbers" data-start="102"><code class="language-javascript line-numbers">}</code></pre></li>
<li><p>The UI is generated using the function that is exported as
<code>default</code>:</p>
<pre class="language-javascript line-numbers" data-start="106"><code class="language-javascript line-numbers">export default function renderGame(root) {</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">// 40 lines skipped</code></pre>
<pre class="language-javascript line-numbers" data-start="147"><code class="language-javascript line-numbers">}</code></pre></li>
<li><p>Styling is treated inline (using a somewhat more sophisticated
method than in the <button data-name="anchor-number-game">Number
Game</button>):</p>
<pre class="language-javascript line-numbers" data-start="33"><code class="language-javascript line-numbers">const <b>h2Styles</b> = {
  margin: 0,
  "text-align": "center",
}</code></pre>
<pre class="language-javascript line-numbers" data-start="60"><code class="language-javascript line-numbers">const <b>applyStyles</b> = (element, styles) =&gt; {
  Object.assign(element.style, styles)
}</code></pre>
<pre class="language-javascript line-numbers" data-start="135"><code class="language-javascript line-numbers">const h2 = document.createElement("h2")
h2.textContent = word
<b>applyStyles(h2, h2Styles)</b></code></pre></li>
</ol>
</details>
<h3 id="cleaning-up-before-moving-in">Cleaning up before moving in</h3>
<p>If you look at both <code>difference.js</code> and
<code>picture-game.js</code>, you will see that, despite their
differences, they both clear out any DOM elements before they start
adding their own. Each of them contains its own <code>clear()</code>
function, which it calls before it does anything else:</p>
<pre class="language-javascript wrap"><code class="language-javascript wrap">const clear = element =&gt; {
  while (element.firstChild) {
    element.firstChild.remove()
  }
}</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">
  const newGame = () =&gt; {
    // Empty the parent element
    clear(root)</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">    // core of newGame() function skipped</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">  }</code></pre>
<p>This is not best practice. Best practice is DRY: Don‚Äôt Repeat
Yourself. In short, <code>picture-game.js</code>, like
<code>difference.js</code>, are independent and self-contained. But they
don‚Äôt need to be. There‚Äôs a better way.</p>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>In this section, you‚Äôve been able to play with three simple games
which can be loaded on demand, using <code>import()</code>. In the
current set-up, the games are mutually exclusive; you can only play one
of them at a time. Each one clears out any DOM components that another
has created before installing its own.</p>
<p>The most troubling is that each is independent of the others: they
share nothing between them.</p>
<p>When working in React, you have been used to creating components that
are stored in a single script but which can be used in multiple places.
As you will see in the next section, this is also possible in plain
JavaScript. In fact, plain JavaScript could do it first.</p>
<p>In the next section, you‚Äôll see how the elements that can be shared
between the games can be broken out into separate modules that all can
use.</p>
</details>
</section>
<!-- Using submodules -->
<section id="using-submodules" aria-labelledby="using-submodules" data-item="Using submodules">
<h2>
<a href="#using-submodules">Using submodules</a>
</h2>
<p>It‚Äôs time to look at the <code>word-game.js</code> script, and its
modular approach.</p>
<p>The <code>word-game.js</code> script is much more compact than the
other two. Much of the code it needs has been externalized in other
modules. The <code>word-game.js</code> module uses static
<code>import ... from ...</code> statements to load the submodules it
needs synchronously as part of module evaluation, before continuing
executing its own code.</p>
<pre class="language-javascript line-numbers" data-start="6"><code class="language-javascript line-numbers"><b>import</b> wordGame <b>from</b> './submodules/word.js'
<b>import</b> words <b>from</b> '../../words.json' with { type: 'json' }
<b>import</b> {
  clear,
  getChoices,
  checkClick
} <b>from</b> './submodules/helpers.js'</code></pre>
<details class="note" open>
<summary>
import ‚Ä¶ with { type: ‚Äújson‚Äù }
</summary>
<p>Notice how the JSON file is imported:</p>
<pre class="language-javascript line-numbers" data-start="7"><code class="language-javascript line-numbers">import words from '../../words.json' <b>with { type: 'json' }</b></code></pre>
<p>The <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with">import
attribute</a> <code>{ type: "json" }</code> that is applied using the
keyword <code>with</code> ensures that the browser parses the incoming
file correctly.</p>
<p>The Internet is often an unsafe place for packets of data, and a file
with the extension <code>.json</code> might actually contain malicious
JavaScript. The browser does not simply parse it as an <em>object</em>:
it parses the incoming data specifically as a <em>JSON object</em>, and
throws an error if this is not the case. Potentially malicious code is
neutralized.</p>
<p>See the <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import/with">MDN
article on the subject</a> for more details.</p>
</details>
<p>The <code>word-game.js</code> file also contains a function to append
a stylesheet to the HTML created by the <code>index.html</code> file,
rather than using inline styles:</p>
<pre class="language-javascript line-numbers" data-start="15"><code class="language-javascript line-numbers">const applyStyles = () =&gt; {
  const link = document.createElement('link')
  link.rel = 'stylesheet'
  link.href = './games/submodules/styles.css'
  document.head.appendChild(link)
}</code></pre>
<p>Finally, it exports a function which itself activates a module which
it imported at the beginning:</p>
<pre class="language-javascript line-numbers" data-start="26"><code class="language-javascript line-numbers">// This function is the module's public API
export default function renderGame(root) {
  applyStyles()
  return wordGame({ root, words, clear, getChoices, checkClick })
}</code></pre>
<p>If you are looking for buzzwords to describe this kind of design
pattern, you might like to read more about:</p>
<ul>
<li><a
href="https://en.wikipedia.org/wiki/Inversion_of_control">inversion of
control</a></li>
<li><a
href="https://en.wikipedia.org/wiki/Dependency_injection">dependency
injection</a></li>
</ul>
<p>Can you see how, from a React perspective, this parallels the way
hooks are passed into components?</p>
<h2 id="the-submodules-folder">The submodules/ folder</h2>
<p>The real work of <code>word-game.js</code> has been delegated to the
imported files. The <code>words.json</code> file is stored at the root
of the <code>Sandbox/</code> folder, because you will be using it later.
The other imported files are stored in <code>submodules/</code>
folder.</p>
<h3 id="submoduleshelpers.js">submodules/helpers.js</h3>
<p>If you compare <code>helper.js</code> with
<code>picture-game.js</code>, you will see that they both include a
number of identical functions.</p>
<p>You don‚Äôt need to understand every line here ‚Äî just notice that none
of these functions know which game they‚Äôre being used in.</p>
<pre class="language-javascript line-numbers" data-start="6"><code class="language-javascript line-numbers">export const clear = element =&gt; {
  while (element.firstChild) {
    element.firstChild.remove()
  }
}


export const getChoices = (words) =&gt; {
  // Choose a random word that did not appear in the last 3 times
  let random = Math.floor(Math.random() * (words.length - 3))
  const word = words.splice(random, 1)[0]
  words.push(word) // move to end of words

  const decoys = [...words]
  // Remove the last word, which cannot be a decoy
  decoys.pop()

  // Choose 3 decoys at random
  const choices = Array.from({ length: 3 })
  choices.forEach(( _, index, array ) =&gt; {
    const random = Math.floor(Math.random() * decoys.length)
    const decoy = decoys.splice(random, 1)[0]
    array[index] = decoy
  })

  // Place the correct word in a random position
  random = Math.floor(Math.random() * 4)
  choices.splice(random, 0, word)

  return { word, choices }
}


export const checkClick = (target, correct, button) =&gt; {
  if (correct) {
    target.classList.add("right")
    button.disabled = false

  } else {
    target.classList.add("wrong")
  }
}</code></pre>
<p>The Word Game needs these functions just as much as the Picture Game
does, so it makes sense to create a separate module that both games can
share. One download: multiple uses.</p>
<p>And as a bonus: you can test these functions in isolation, to make
sure that they do exactly what you expect, before making other modules
depend on them.</p>
<details class="note" open>
<summary>
Named exports, but no default export
</summary>
<p>Notice that the functions in <code>helpers.js</code> are all declared
in a similar way, with an obligatory name:</p>
<pre class="language-javascript wrap"><code class="language-javascript wrap">export const functionNameRequired = (parameters) =&gt; { ... }</code></pre>
<p>None of the functions are exported as <code>default</code>, like you
have seen before:</p>
<pre class="language-javascript wrap"><code class="language-javascript wrap">export default function optionalFunctioName(parameters) { ... }</code></pre>
<strong>Question: Without a default export, what will the imported
object look like?</strong>
<details class="answer">
<summary>
Answer
</summary>
<p>As you might expect: the imported module is an object with no
<code>default</code> key:</p>
<pre>{
  checkClick: checkClick(target, correct, button),
  clear:      clear(element),
  getChoices: getChoices(words),
  Symbol(Symbol.toStringTag): "Module"
}
</pre>
</details>
</details>
<h3 id="submodulesword.js">submodules/word.js</h3>
<p>The <code>submodules/word.js</code> script receives the
<code>clear()</code>, <code>getChoices()</code> and
<code>checkClick()</code> functions in the call it receives from
<code>word-games.js</code>, along with the <code>words</code> array, and
the <code>root</code> DOM element that has been forwarded from the
<code>script.js</code> module.</p>
<p>All the rest of the code in the <code>submodules/word.js</code>
script is specific to this one game. The <code>newGame()</code> function
simply creates the DOM elements needed for one iteration of this
particular game.</p>
<p>Note that there are no inline styles. Styling is taken care of by the
stylesheet that was appended to the HTML <code>&lt;head&gt;</code>.</p>
<pre class="language-javascript line-numbers" data-start="6"><code class="language-javascript line-numbers">export default function gameCore({
  root,
  words,
  clear,
  getChoices,
  checkClick
}) {
  const newGame = () =&gt; {
    // Empty the parent element
    clear(root)

    // Choose a target word and three decoys
    const { word, choices } = getChoices(words)

    // Recreate the game UI with a custom div inside root
    const space = document.createElement("div")
    space.className = "word-game"
    root.append(space)

    const title = document.createElement("h2")
    title.textContent = "Choose the Word"
    space.append(title)

    const image = document.createElement("img")
    image.src = `../images/${word}.webp`
    image.alt = word
    space.append(image)

    const p = document.createElement("p")
    choices.forEach( text =&gt; {
      const span = document.createElement("span")
      span.textContent = text
      span.addEventListener(
        "click",
        ({target}) =&gt; checkClick( target, text === word, button ))
      p.append(span)
    })
    space.append(p)

    const button = document.createElement("button")
    button.type = "button"
    button.textContent = "Next Image"
    button.addEventListener("click", newGame)
    button.disabled = true
    space.append(button)
  }

  // Force game() to run as soon as gameCore() is called
  newGame()
}</code></pre>
<h2 id="really">Really?</h2>
<p>I just wrote: ‚ÄúAll the rest of the code in the
<code>submodules/word.js</code> script is specific to this one game‚Äù.
It‚Äôs time for you to prove me wrong, in the following challenge.</p>
<details class="challenge" open>
<summary>
Challenge: Refactoring the Games
</summary>
<p>How much of the code in <code>word-game.js</code> and its submodules
can be shared with the Picture Game?</p>
<p>Your challenge (if you accept it) is to refactor the files in the
‚Äô05-three-games/` folder, so that the least amount of bandwidth is used
when a visitor plays all three games.</p>
<p>Consider that you are ‚Äúcoding by differences‚Äù. Any time you find
something that is duplicated in two or more scripts, move that thing out
into a module, and import it into the scripts that need to use it.</p>
<p>Do your best to come up with a neat, elegant solution, before you
look at my scoring system and my suggested answer.</p>
<details class="solution">
<summary>
Scoring
</summary>
<p>You can earn a total of 30 points.</p>
<ul>
<li>1 point for moving <code>applyStyles()</code> from
<code>word-game.js</code> into <code>helpers.js</code></li>
<li>1 point for making it possible to customize the url for the
stylesheet in the <code>applyStyles()</code> call</li>
<li>2 point for noticing that the creation of the button that triggers
<code>newGame()</code> is common to all three games, and can be moved to
<code>helpers.js</code></li>
<li>1 point for making it possible to customize the name of this
button</li>
<li>3 points for noticing that the <code>differences-game.js</code>
module can use the same <code>clear()</code>, <code>checkClick()</code>
and <code>newButton()</code> functions as the other two games, so you
can import these from <code>helpers.js</code></li>
<li>4 points for expanding <code>styles.css</code> so that it can be
used for all three games</li>
<li>4 points for noticing that now the only difference between any of
the games is the module that generates the UI for the game, and that
this means you can reduce the files <code>differences-game.js</code>,
<code>picture-game.js</code> and <code>word-game.js</code> to thin entry
points</li>
<li>10 points for creating a generic game module for your thin entry
points to use. You can only get this points if your generic module
gathers up the data and functions required by all the games, and calls
the appropriate game UI function with all the necessary information</li>
<li>4 points for arranging all the files in a folder hierarchy, and for
giving all your files and folders meaningful names.</li>
</ul>
<p>You‚Äôll find my solution (for which I award myself 30 points) in
<code>06-three-modularized-games/</code>. And you can award yourself a
bonus of 20 points if your own solution is better than mine.</p>
</details>
</details>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>In this section, you‚Äôve seen a different way to structure a game
module: instead of doing everything in one file,
<code>word-game.js</code> acts as a thin entry point that pulls together
data, shared helpers, styles, and a game-specific UI module.</p>
<p>Static imports determine what gets bundled together. Anything that
<code>word-game.js</code> imports synchronously becomes part of the same
download, and anything that lives outside that boundary can be shared
with other games at no extra cost.</p>
<p>By pushing common logic into submodules, you reduce duplication, make
the code easier to test, and ensure that shared functionality is loaded
once and reused. The result is a design that scales: adding new games
means writing only what‚Äôs different, while everything else stays the
same.</p>
<p>You‚Äôve also had the chance to practice refactoring code you didn‚Äôt
write, with the explicit goal of optimizing it for code splitting.</p>
<p>In the next section, you‚Äôll see the same ideas expressed in JSX, and
explore why React needs to provide <code>lazy()</code> and
<code>Suspense</code> when components are loaded dynamically with
<code>import()</code>.</p>
</details>
</section>
<section id="intro" aria-labelledby="intro" data-item="Introduction">
<h2>
<a href="#intro">A Use Case for Code Splitting</a>
</h2>
<p>Alice teaches French as a foreign language. She has a smartboard in
her classroom, and there are enough tablets for all her students. She
wants to create a number of fun activities, to encourage her students to
practice their new language, and she has a vivid imagination. Ideally,
she wants web app with a single simple URL, to which she (or rather we)
can add new activities from time to time, as her plans crystallize.</p>
<p>To begin with, the app will have a single activity, and it won‚Äôt take
long to load. But over time, the amount of code and assets required for
all the activities that Alice plans will become too much to load all at
once. Why make the end-user wait while the code and assets load for
activities that are not yet needed? Why not load files just in time?</p>
<p>What we need to create is basicly a <em>generic engine</em> whose
possibilities can evolve organically, without us having to rewrite the
core code each time a new activity is added.</p>
<p><strong>Code splitting</strong> seems to be the solution. So that‚Äôs
what this tutorial is about.</p>
<h2 id="sneak-preview">Sneak preview</h2>
<p>In this tutorial, you won‚Äôt be building the powerhouse app that Alice
wants. Your own project has very different requirements.</p>
<p>Instead, you‚Äôll be building an app with three ultra-simple language
games that are loaded on demand. This will be enough for you to master
the necessary techniques. It will be up to you to replace these simple
games with features that you actually need in your own project.</p>
<p>The app that you will create here will look something like this:</p>
<iframe id="iframe-split" title="iframe-split" width="300" height="150" src="https://merncraft.github.io/Lazy-Loading-Project/">
</iframe>
</section>

<div class="spacer"></div>
<footer id="content-footer">
<button type="button" class="previous" disabled>
  <img src="../public/svg/prev.svg" alt="prev" draggable="false">
</button>
<span class="previous-name"></span>
<span class="spacer"></span>
<button type="button" class="next">
  <img src="../public/svg/next.svg" alt="next" draggable="false">
</button>
<span class="next-name"></span>
</footer>
</main>

<nav
id="menu"
aria-labelledby="menu"
class="open"
>
<div class="theme">
  <label
  title="Dark"
  >
  <img src="../public/svg/dark.svg" alt="dark">
  <input
  type="radio"
  name="theme"
  id="theme-dark"
  checked
  >
  </label>
  <label
  title="Light"
  >
  <img src="../public/svg/light.svg" alt="light">
  <input
  type="radio"
  name="theme"
  id="theme-light"
  >
  </label>
  </div>
  <div class="paging">
  <label
  title="Split into sections"
  >
  <img src="../public/svg/pages.svg" alt="pages">
  <input
  type="radio"
  name="paging"
  id="pages"
  checked
  >
  </label>
  <label
  title="Show as a single page"
  >
  <img src="../public/svg/scroll.svg" alt="scroll">
  <input
  type="radio"
  name="paging"
  id="scroll"
  >
  </label>
  </div>
<img src="../public/svg/hamburger.svg" alt="menu" id="menu-icon">

<ul id="menu-items">
</ul>
<div id="repo">
<a
href="https://github.com/MERNCraft/Lazy-Loading/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/Lazy-Loading"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>