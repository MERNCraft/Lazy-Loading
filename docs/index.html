<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>Code Splitting with React and Vite</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="content">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>Code Splitting with React and Vite</h1>
<h3>using import(), React.lazy() and React.Suspense</h3>
<h4>February 2026</h4>
</header>
<nav
  id="content-header"
  aria-labelledby="content-header"
>
  <button type="button" class="previous" disabled>
    <img src="../public/svg/prev.svg" alt="previous" draggable="false">
  </button>
  <span class="previous-name"></span>
  <span class="spacer"></span>
  <button type="button" class="next">
    <img src="../public/svg/next.svg" alt="next" draggable="false">
  </button>
  <span class="next-name"></span>
</nav>

<!-- prerequisites -->
<section id="prerequisites" aria-labelledby="prerequisites" data-item="Prerequisites">
<h2>
<a href="#prerequisites">Prerequisites</a>
</h2>
<p>This tutorial assumes that you are already comfortable with the
basics of React, and that you have already created a number of
interactive apps with a single focus. In particular, I expect you to
know about:</p>
<ul>
<li><a
href="https://react.dev/reference/react/Component">Components</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a></li>
<li><a
href="https://react.dev/learn/passing-data-deeply-with-context">Contexts,
Providers</a> and <a
href="https://react.dev/reference/react/useReducer">Reducers</a></li>
</ul>
<p>If any of these concepts are unfamiliar to you, please follow the
links provided before you continue.</p>
<h2 id="development-environment-and-local-server">Development
environment and local server</h2>
<p>I also assume that you are working with an IDE (Integrated
Development Environment) like VS Code, which allows you to open HTML
files using an extension like Live Server. This means that I can
separate the code you‚Äôll be writing into different files, each with a
single purpose.</p>
<p>You can download these files from <a
href="https://github.com/MERNCraft/Lazy-Loading-Sandbox">here</a>.</p>
</section>
<!-- What is Code Splitting -->
<section id="what-is-code-splitting" aria-labelledby="what-is-code-splitting" data-item="What is Code Splitting?">
<h2>
<a href="#what-is-code-splitting">What is Code Splitting?</a>
</h2>
<p>In a simple React project, the final <code>build</code> process
creates three files:</p>
<ul>
<li>a minified JavaScript file</li>
<li>a compact CSS file</li>
<li>a skeleton <code>index.html</code> file which loads the JavaScript
and CSS files</li>
</ul>
<p>When you open the production version of your app, the
<code>index.html</code> file is downloaded first, and the
<code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags it
contains in its <code>&lt;head&gt;</code> trigger the download of the
JavaScript and CSS files, and the JavaScript file in turn may trigger
the download of various assets.</p>
<p>In other words, there is a one-time flood of data from the server,
and then everything the app needs is available locally. But this flood
can take a significant amount of time.</p>
<p>With code splitting, your build tool creates separate JavaScript and
CSS files for each feature, and only loads those file when they are
explicitly requested. This means that the initial download of data is
minimized, but there may be a delay before a newly-requested feature is
operational, while its files download.</p>
<h2 id="how-does-your-build-tool-know-where-to-split-your-code">How does
your build tool know where to split your code?</h2>
<p>The answer is: you tell your build tool where to split your code by
the way you write it. You indicate where the code should be split with
requests for <code>import()</code>.</p>
<p>Since early 2019, <a
href="https://caniuse.com/?search=import%28%29">all major browsers</a>
support the <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">dynamic
<code>import()</code></a> feature. Dynamic import allows you to load a
module asynchronously at run-time.</p>
<p>During the build process, your build tool will notice every time you
use the <code>import()</code> syntax, and will bundle each block of
imported code into its own JavaScript and CSS files. The main JS file
that is requested by the <code>index.html</code> file will contain the
relative URLs of each of these feature bundles, so it can
<code>import()</code> them whenever they are needed.</p>
<h2 id="the-challenges">The challenges</h2>
<p>Imagine this scenario: you click on a link to an activity which
downloads a feature bundle. Let‚Äôs call this Activity A. You start
working with Activity A, and then you switch to a different activity.
When you come back to Activity A later, you find that all the changes
you have made have been forgotten, and you are back to where the
activity started.</p>
<p>When you navigate away from an activity, your browser dismounts the
components associated with it, and all the state associated with those
components is lost. One solution is to keep the state for the activity
in a Context which does not get dismounted. If you do that, you can
restore the component state from the Context when the activity is
remounted later.</p>
<p>If the Context only contains state for Activity A, then it would make
sense to import it at the same time as the components for Activity A,
but then you have to insert the Context‚Äôs Provider into your app‚Äôs
component hierarchy, as a parent or ancestor of the activity
components.</p>
<p>If you later add a new activity (Activity B) that needs to store some
of the same state as Activity A, you might need to place the shared
Provider higher up the component hierarchy, so that it can make the
Context available to both activities.</p>
<h2 id="building-a-code-splitting-app-step-by-step">Building a
code-splitting app, step by step</h2>
<p>I plan to show, step-by-step, how code splitting works in a React
frontend. I‚Äôll show you how to build an app where you can simply create
a new directory in your development environment that contains all the
code and assets that you need for a new activity, so that the new
version of the deployed app will be able to load the activity on the
fly. I‚Äôll show you how to ensure that each activity maintains its state
if you navigate to a different activity and back.</p>
</section>
<!-- Installing the Work Files -->
<section id="installing-the-work-files" aria-labelledby="installing-the-work-files" data-item="Installing the Work Files">
<h2>
<a href="#installing-the-work-files">Installing the Work Files</a>
</h2>
<p>Eventually, I‚Äôll show you how to build a demo app using <a
href="https://en.wikipedia.org/wiki/Npm">npm</a> and <a
href="https://vite.dev/">Vite</a> to provide a sturdy development
framework. But for now, you can use something more lightweight.</p>
<p>Browsers cannot understand the JSX syntax that React uses, so your
React code has to be compiled to plain JavaScript before it is deployed
to a server. Vite provides all the tools you need to compile your code
and create a production-ready app. For this tutorial, though, you can
use <a href="https://esbuild.github.io/">esbuild</a> to take care of
compilation. Vite is built on top of esbuild, so the JavaScript output
will be the same. You‚Äôll just have to provide your own local server to
host the files you create.</p>
<h2 id="preparing-a-workspace">Preparing a workspace</h2>
<p>Clone or download the files in this repository: <a
href="https://github.com/MERNCraft/Lazy-Loading-Sandbox">Lazy-Loading
Sandbox</a>.</p>
<p>Open your IDE and a Terminal window inside the Sandbox directory. You
should see a folder hierarchy like this:</p>
<pre class="line-numbers"><code class="line-numbers">.
‚îú‚îÄ‚îÄ 01
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ 02
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ .../
‚îú‚îÄ‚îÄ build.mjs
‚îú‚îÄ‚îÄ buildAll.mjs
‚îú‚îÄ‚îÄ cleanUp.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md</code></pre>
<p>Each numbered folder contains a mini-app for you to practise with,
but these have to be compiled to JavaScript before you can open them in
your browser.</p>
<h2 id="installing-node-modules">Installing node modules</h2>
<p>In the Terminal run this command:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i esbuild react react-dom</code></pre>
<p>You should see a new folder appear in your Sandbox directory:</p>
<pre class="line-numbers"><code class="line-numbers">‚îÜ
‚îú‚îÄ‚îÄ node_modules
‚îÇ   ‚îú‚îÄ‚îÄ @esbuild
‚îÇ   ‚îú‚îÄ‚îÄ esbuild
‚îÇ   ‚îú‚îÄ‚îÄ react
‚îÇ   ‚îú‚îÄ‚îÄ react-dom
‚îÇ   ‚îî‚îÄ‚îÄ scheduler
‚îÜ</code></pre>
<p>I assume that you are used to seeing <code>react</code>,
<code>react-dom</code> and <code>scheduler</code> in your dependencies.
The <code>esbuild</code> module is the one which will compile your React
code to JavaScript and perform code splitting for you.</p>
<h2 id="building-all-the-mini-apps-at-once">Building all the mini-apps
at once</h2>
<p>Each mini-app is contained in a numbered folder. To minimize the
download size, none of the mini-apps have been built for deployment. To
do this, run the following command in your Terminal:</p>
<p><code>node buildAll.mjs</code></p>
<p>This will tell the buildAll.mjs script to create an
<code>assets/</code> subfolder inside each of the numbered folders. This
will look something like this, but the exact names of the files may be
different:</p>
<pre class="line-numbers"><code class="line-numbers">.
‚îú‚îÄ‚îÄ 01
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.js.map
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chunk-UASCOLGB.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chunk-UASCOLGB.js.map
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LazyComponent-C4ZJBLUW.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent-C4ZJBLUW.js.map
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent.jsx
‚îú‚îÄ‚îÄ .../
‚îú‚îÄ‚îÄ launch.mjs
‚îú‚îÄ‚îÄ buildAll.mjs
‚îú‚îÄ‚îÄ cleanUp.js
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md</code></pre>
<h2 id="opening-a-mini-app-in-your-browser">Opening a mini-app in your
browser</h2>
<p>Use your local server to open the <code>index.html</code> file in any
of the numbered folders. If you are working with VS Code, this is how
you do this:</p>
<figure>
<img src="images/live-server.webp"
alt="Opening an HTML file with Live Server in VS Code" />
<figcaption aria-hidden="true">Opening an HTML file with Live Server in
VS Code</figcaption>
</figure>
<p>The file should open in your browser:</p>
<figure>
<img src="images/01-index.webp"
alt="You can inspect the React code in the browser‚Äôs Debugger" />
<figcaption aria-hidden="true">You can inspect the React code in the
browser‚Äôs Debugger</figcaption>
</figure>
<details class="alert" open>
<summary>
Double-click doesn‚Äôt work
</summary>
<p><strong>You must use a local server to open the
<code>index.html</code> files.</strong></p>
<p>If you simply double-click on a mini-app <code>index.html</code> file
on your desktop, it <em>will</em> open in your browser, but, for your
safety, the browser will refuse to load any files via the
<code>import()</code> command, so none of the code splitting features
will work.</p>
<figure>
<img src="images/01-file.webp"
alt="import() is not supported for URLs with the file:/// protocol" />
<figcaption aria-hidden="true">import() is not supported for URLs with
the <code>file:///</code> protocol</figcaption>
</figure>
</details>
</section>
<!-- The Simplest Split -->
<section id="the-simplest-split" aria-labelledby="the-simplest-split" data-item="The Simplest Split">
<h2>
<a href="#the-simplest-split">The Simplest Split</a>
</h2>
<p>In the Sandbox folder that you created in the
<a href="#installing-the-work-files">last step</a>, take a look at the
files at the root of the <code>01/</code> folder:</p>
<h2 id="index.html">index.html</h2>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;Code Splitting <b>01</b>&lt;/title&gt;
  &lt;!-- The build step guarantees this is a valid link --&gt;
  <b>&lt;script defer type="module" src="./assets/App.js"&gt;&lt;/script&gt;</b>
&lt;/head&gt;
&lt;body&gt;
  <b>&lt;div id="root"&gt;&lt;/div&gt;</b>
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>This is a generic HTML file, which is identical in every numbered
folder, except that the title changes to match the folder name:</p>
<pre class="language-html line-numbers" data-start="5"><code class="language-html line-numbers">  <i>&lt;title&gt;Code Splitting </i><b>01</b><i>&lt;/title&gt;</i></code></pre>
<p>It simply defines‚Ä¶</p>
<pre class="language-html line-numbers" data-start="10"><code class="language-html line-numbers">&lt;div id="root"&gt;&lt;/div&gt;</code></pre>
<p>‚Ä¶ which React will use as the container for all the DOM elements that
it generates, and it loads the <code>App.js</code> script from the
<code>assets/</code> folder, which was created by the
<code>esbuild</code> when you ran <code>node buildAll.mjs</code>.</p>
<pre class="language-html line-numbers" data-start="7"><code class="language-html line-numbers">  &lt;script defer type="module" src="./assets/App.js"&gt;&lt;/script&gt;</code></pre>
<h2 id="app.jsx">App.jsx</h2>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import { Suspense, lazy } from 'react';
import { createRoot } from 'react-dom/client';

const LazyComponent = lazy(() =&gt; import('./LazyComponent.jsx'))

function App() {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;LazyComponent /&gt;
    &lt;/Suspense&gt;
  );
}

createRoot(document.getElementById('root')).render(&lt;App /&gt;);</code></pre>
<p>The <code>App.jsx</code> file implements many powerful concepts that
I‚Äôll explain in the following sections. In short, it uses‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="4"><code class="language-javascript line-numbers"><b>import</b>('./LazyComponent.jsx')</code></pre>
<p>‚Ä¶ to load the <code>LazyComponent.jsx</code> file asynchronously at
run time, and it uses <code>lazy()</code> and
<code>&lt;Suspense&gt;</code> to handle this import elegantly for React.
More about this later.</p>
<h2 id="lazycomponent.jsx">LazyComponent.jsx</h2>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function LazyComponent() {
  return &lt;h1&gt;I am lazy.&lt;/h1&gt;;
}</code></pre>
<p><code>LazyComponent.jsx</code> is an ultra-simple component function,
which shows the text <code>"I am lazy."</code> as a header.</p>
<p><strong>Note that the <code>LazyComponent()</code> function is
explicitly exported as the <code>default</code>. This makes it easier
for the <code>React.lazy</code>, which expects the dynamically imported
module to provide a <code>default</code> export.</strong> You‚Äôll see how
to deal with named exports later.</p>
<h2 id="assets">assets/</h2>
<p>The <code>assets/</code> folder, which was created by the build
process, contains 6 files.</p>
<p>The random-looking last eight letters in a file‚Äôs name are a hash of
its contents. The name will stay the same, so long as the contents do
not change. This means that the browser can safely cache the file,
knowing that when a file with an identical name is requested, its
contents will be identical. This means it it is safe to use its cached
copy instead of triggering a new download.</p>
<p>However, if the contents of any file have changed since I wrote this
tutorial, then the hashes that you see will be different.</p>
<pre class="line-numbers"><code class="line-numbers">01
‚îú‚îÄ‚îÄ App.jsx
‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îú‚îÄ‚îÄ App.js
‚îÇ   ‚îú‚îÄ‚îÄ App.js.map
‚îÇ   ‚îú‚îÄ‚îÄ chunk-U3XB4E5Q.js
‚îÇ   ‚îú‚îÄ‚îÄ chunk-U3XB4E5Q.js.map
‚îÇ   ‚îú‚îÄ‚îÄ LazyComponent-27PLPFAM.js
‚îÇ   ‚îî‚îÄ‚îÄ LazyComponent-27PLPFAM.js.map
‚îú‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ LazyComponent.jsx</code></pre>
<h3 id="the-.map-files">The <code>.map</code> files</h3>
<p>The files with the extension <code>.map</code> are not required for
your code to run. They are used by the browser to make it easier for you
to use the Debugger. Thanks to the <code>.map</code> files, you can step
through your original JSX code, and the browser will follow your steps
through the compiled JavaScript code behind the scenes for you.</p>
<figure>
<img src="images/01-mapped.webp"
alt="Inspecting the original JSX code in the browser Debugger" />
<figcaption aria-hidden="true">Inspecting the original JSX code in the
browser Debugger</figcaption>
</figure>
<p>Without the <code>.map</code> files, the JSX code will not be
available, and all the browser can show you is the compiled JavaScript
code, which you didn‚Äôt write and which is much more complex to
follow.</p>
<figure>
<img src="images/01-mapless.webp"
alt="Without the .map files, the browser Debugger is harder to use" />
<figcaption aria-hidden="true">Without the .map files, the browser
Debugger is harder to use</figcaption>
</figure>
<h3 id="app.js">App.js</h3>
<p><code>App.js</code> is a pure JavaScript file, and it is huge. It
contains all the code that React wants to use at runtime, and which
<code>esbuild</code> chose not to place in the
<code>chunk-XXXXXXXX.js</code>, in addition to the compiled version of
the original <code>App.jsx</code> file.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import {
  __commonJS,
  __toESM,
  require_jsx_runtime,
  require_react
} from "./chunk-U3XB4E5Q.js";</code></pre>
<pre class="language-javascript wrap"><code class="language-javascript wrap">// Over 20000 lines skipped, then the code compiled from App.jsx... //</code></pre>
<pre class="language-javascript line-numbers" data-start="20448"><code class="language-javascript line-numbers">// 01/App.jsx
var require_App = __commonJS({
  "01/App.jsx"() {
    var import_react = __toESM(require_react());
    var import_client = __toESM(require_client());
    var import_jsx_runtime = __toESM(require_jsx_runtime());
    var LazyComponent = (0, import_react.lazy)(() =&gt; import("./LazyComponent-27PLPFAM.js"));
    function App() {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: "Loading..." }), children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LazyComponent, {}) });
    }
    (0, import_client.createRoot)(document.getElementById("root")).render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, {}));
  }
});
export default require_App();</code></pre>
<h3 id="chunk-xxxxxxxx.js">chunk-XXXXXXXX.js</h3>
<p>The file whose name begins <code>chunk-</code> and which has the
extension <code>.js</code> contains code that <code>esbuild</code> chose
share between multiple modules.</p>
<p>It only exists because the <code>App.jsx</code> code contains
<code>import()</code>, and because the <code>App.jsx</code> file and the
<code>LazyComponent.jsx</code> file both need access to the same React
functions.</p>
<p>It, too, is a fairly big file, and it would be even bigger if your
split modules had more code in common.</p>
<p>It will be downloaded when the browser is executing
<code>App.js</code> and encounters a static import from
<code>chunk-XXXXXXXX.js</code>, as a dependency.</p>
<h3 id="lazycomponent-xxxxxxxx.js">LazyComponent-XXXXXXXX.js</h3>
<p>LazyComponent has been given its own file, because it is loaded by
the <code>import()</code> command. It is a fairly small file, because
all the React features it requires have already been included in
<code>App.js</code> or <code>chunk-XXXXXXXX.js</code>. React runtime
helpers have been placed in the shared chunk, while App.js contains
application glue code.</p>
<p>Its contents are a pure JavaScript version of
<code>LazyComponent.jsx</code>.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">import {
  __esm,
  __toESM,
  require_jsx_runtime
} from "./chunk-U3XB4E5Q.js";

// 01/LazyComponent.jsx
function LazyComponent() {
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", { children: "I am lazy." });
}
var import_jsx_runtime;
var init_LazyComponent = __esm({
  "01/LazyComponent.jsx"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
  }
});
init_LazyComponent();
export {
  LazyComponent as default
};
//# sourceMappingURL=LazyComponent-27PLPFAM.js.map</code></pre>
<details class="note" open>
<summary>
The weight of React
</summary>
<p>Take a moment to compare the size of the raw App.jsx file and the
size of the JavaScript bundle that now includes your code and its
dependencies. <code>App.js</code> is around 3000 times larger than
<code>App.jsx</code>.</p>
<p>But I said that the whole purpose of this tutorial was to show you
how to reduce the size of the initial download, didn‚Äôt I?</p>
<p>No worries. Most of this size increase does not come from your code,
but from bundling React and ReactDOM into the same file.</p>
<figure>
<img src="images/compiled-size.webp"
alt="Comparing the compiled file with the raw JSX" />
<figcaption aria-hidden="true">Comparing the compiled file with the raw
JSX</figcaption>
</figure>
<p>To be fair, at this point, <code>esbuild</code> is transpiling the
JSX for development purposes, so it is generating unminified JavaScript
and helpers that are useful during dev-time debugging.</p>
<p>There are ways to reduce the amount of production code that your
server will deploy for the Internet, using minification and
tree-shaking, but this tutorial is not the place to discuss that.</p>
<p>The arguments for using React are:</p>
<ol type="1">
<li><p><strong>Productivity now</strong></p>
<p>You‚Äôll complete your projects faster with the tools that React
provides.</p></li>
<li><p><strong>Real-world context</strong></p>
<p>The production-ready projects that you will be working on are far
more complex than what is covered by this tutorial</p></li>
<li><p><strong>Future-proofing</strong></p>
<p>Unused power today is likely to be used later. The actual project
that I am creating will eventually contain activities that have not even
been thought of yet. React gives me room to expand.</p></li>
</ol>
<p>However, if you have just a small project that you know is never
going to grow big, it might be worthwhile writing it in plain
JavaScript.</p>
</details>
</details>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>In summary, <code>esbuild</code> has split the code of this mini-app
into three files:</p>
<ol type="1">
<li>The entry-point bundle for App.jsx, with all the code for running
the pure JavaScript version of App.jsx</li>
<li>Code shared between the compiled versions of App.jsx and
LazyComponent.jsx</li>
<li>The code specific to each module that is loaded with the
<code>import()</code> command. (In this case, there is only one such
module).</li>
</ol>
<p>For each of these three files, <code>esbuild</code> has also created
a file with a <code>.map</code> extension, to help you when you are
stepping through or debugging your JSX code.</p>
<h2 id="import-lazy-and-suspense">import(), lazy() and Suspense</h2>
<p>In the next sections, you can explore how <code>import()</code>,
<code>lazy()</code> and <code>Suspense</code> work, separately and
together.</p>
<p>The <code>import()</code> command is native JavaScript.
<code>Suspense</code> and <code>lazy()</code> are React-specific
features, designed to handle the asynchronous nature of
<code>import()</code> cleanly in a React environment.</p>
</details>
</section>
<!-- Dynamic import() -->
<section id="dynamic-import" aria-labelledby="dynamic-import" data-item="Dynamic import()">
<h2>
<a href="#dynamic-import">Dynamic import()</a>
</h2>
<p>The <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"><code>import()</code>
command</a> is native JavaScript. You can use it completely
independently of React. Its purpose is to request a JavaScript module by
URL, downloading it if it has not already been loaded, and to return a
<a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
This Promise should resolve to the usable contents of the file if the
download is successful.</p>
<h2 id="proof-of-concept">Proof of concept</h2>
<p>Here‚Äôs a very simple demo of dynamic <code>import()</code> at work.
You can create your own scripts similar to the ones listed below, or you
can open the <code>03_import_demo</code> subfolder in your
<code>Sandbox/</code> folder.</p>
<p>In either case, you‚Äôll need to open the <code>index.html</code> file
with your local server, for the reasons explained
<button data-name="anchor-opening-a-mini-app-in-your-browser">here</button>.</p>
<h3 id="index.html-1">index.html</h3>
<p>A simple HTML file with a button and a <code>&lt;div&gt;</code> with
the <code>id</code> ‚Äúgame-space‚Äù, which is where an imported module will
appear after the button is clicked.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Import() Demo&lt;/title&gt;
  &lt;script defer src="script.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;button id="button"&gt;
    Import Placeholder Module
  &lt;/button&gt;
  &lt;div id="game-space"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 name="anchor-import-placeholder">
script.js
</h3>
<p>The JavaScript file that is loaded directly by
<code>index.html</code>. I‚Äôll describe how it works shortly.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">const button = document.getElementById("button")
const gameSpace = document.getElementById("game-space")

button.addEventListener("click", importGame)

function importGame() {
  const url = `./placeholder.js`
  const promise = import(url)
  promise
    .then(result =&gt; {
      console.log("result:", result)
      return result.default
    })
    .then(renderGame =&gt; renderGame(gameSpace))
    .catch(error =&gt; console.error(error))
}</code></pre>
<h3 id="placeholder.js">placeholder.js</h3>
<p>The external JavaScript file which will be imported by a click on the
button. It does nothing special. It simply indicates its presence by
adding some text to the <code>#game-space</code> div, a pointer to which
is passed to it by the <code>root</code> argument.</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function (root) {
  root.textContent = "üéâ Placeholder module loaded!";
}

console.log("Placeholder module evaluated")</code></pre>
<h2 id="testing-this-proof-of-concept">Testing this proof of
concept</h2>
<p>Launch <code>index.html</code> with your local server. You should see
a button:</p>
<figure>
<img src="images/03-placeholder-button.webp"
alt="Before the Import Placeholder Module button is pressed" />
<figcaption aria-hidden="true">Before the Import Placeholder Module
button is pressed</figcaption>
</figure>
<p>Click on the button. You should see that the function from
placeholder.js has been called and the <code>textContent</code> of the
<code>#game-space</code> div has been set.</p>
<figure>
<img src="images/03-placeholder-loaded.webp"
alt="After the Placeholder Module button is loaded" />
<figcaption aria-hidden="true">After the Placeholder Module button is
loaded</figcaption>
</figure>
<h2 id="modules-and-json-imports">Modules and JSON imports</h2>
<p>You can use the <code>import</code> keyword to load either functional
code from a <code>.js</code> file or data from a <code>.json</code>
file. I‚Äôll explain how to import JSON data later.</p>
<p>A JavaScript file that is loaded using import is called a
<code>module</code>. A module exports one or more objects. These objects
may be functions, plain old JavaScript objects (POJOs) created with
<code>{}</code> curly brackets, or arrays. A module can export one
object as <code>default</code>. Any other object it exports must have a
name. The example you have just tested uses an anonymous function
exported as <code>default</code>. You‚Äôll see other possibilities later
in the tutorial.</p>
<details class="note" open>
<summary>
<code>import</code> vs <code>require</code>
</summary>
<p>You may have used the <code>require</code> keyword in Node projects.
This has a similar, but not identical, function, and browsers do not
support <code>require</code>. In particular, <code>require()</code> is
synchronous. Node.js stops executing the current script while it loads
the required file and executes <em>it</em>. This is fine when the
required file is stored locally on the server and can be loaded
fast.</p>
<p>In a browser, it can take some time before a file is downloaded, so
<code>import</code> works asynchronously, and returns a <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
This <code>Promise</code> needs to be resolved before it can be
used.</p>
</details>
<h2 id="understanding-function-importgame">Understanding function
importGame()</h2>
<p>This is the code which is executed when you click on the Import
Placeholder Module button:</p>
<pre class="language-javascript line-numbers" data-start="7"><code class="language-javascript line-numbers">  const url = `./placeholder.js`
  const promise = import(url)
  promise
    .then(result =&gt; {
      console.log("result:", result)
      return result.default
    })
    .then(renderGame =&gt; renderGame(gameSpace))
    .catch(error =&gt; console.error(error))</code></pre>
<p>Things to notice:</p>
<ol type="1">
<li><p>The path to the file to import is given by a URL. This can be
relative to the location of the page that calls it (as in the case
above), or it can be an absolute URL to a file on some other
server.</p></li>
<li><p>The <code>import()</code> call returns a promise. When this
resolves, the <code>.then()</code> function logs it to the console, so
that you can see that the resolved value is an object with a property
<code>default</code>, whose value is the anonymous function from
<code>placeholder.js</code>, which has now been given a name:
<code>default</code>.</p>
<pre class="console line-numbers"><code class="console line-numbers">Object {
  default: function default(root)
  Symbol(Symbol.toStringTag): "Module"
}</code></pre></li>
</ol>
<p>In addition there is a Symbol with the value ‚ÄúModule‚Äù. This symbol
indicates that the object represents an ES module. All ES modules are
automatically executed in <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">‚Äústrict
mode‚Äù</a>. This means that you will see more meaningful errors, and the
browser can perform certain optimizations which are not available in
JavaScript‚Äôs default <a
href="https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode">‚Äúsloppy‚Äù
mode</a>.</p>
<ol start="3" type="1">
<li><p>I‚Äôve explicitly used a Promise here, rather than the sweeter
<code>async/await</code> syntax that you might already know. This is
simply to underline the fact that the output of <code>import()</code> is
a Promise which must be resolved before the imported module can be
used.</p></li>
<li><p>Line 14 then receives this <code>default</code> function and
renames it to <code>renderGame</code> and then executes it. Which is how
the <code>textContent</code> of the <code>#game-space</code> div got
set.</p></li>
</ol>
<h2 id="multiple-import-calls-only-one-download">Multiple import()
calls, only one download</h2>
<p>You may already have noticed evidence that the
<code>placeholder.js</code> file is only downloaded once. If you open
the Console tab of your Developer Tools, you should see that the
line‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="5"><code class="language-javascript line-numbers">console.log("Placeholder module evaluated")</code></pre>
<p>‚Ä¶ logs only one message in the Console, even if you click on the
Import Placeholder Module multiple times.</p>
<figure>
<img src="images/03-single-download.webp"
alt="‚ÄúPlaceholder module evaluated‚Äù is logged to the console only once" />
<figcaption aria-hidden="true">‚ÄúPlaceholder module evaluated‚Äù is logged
to the console only once</figcaption>
</figure>
<p>Once the browser has downloaded the file and evaluated it, it will
not ask for it again, even if you disable the browser cache.</p>
<figure>
<img src="images/03-downloaded-once.webp"
alt="The Network tab only shows one download, even when caching is disabled" />
<figcaption aria-hidden="true">The Network tab only shows one download,
even when caching is disabled</figcaption>
</figure>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>The points to note here are:</p>
<ul>
<li><code>import()</code> returns a Promise which must be resolved
before the imported module can be used</li>
<li>The imported module is evaluated once and for all</li>
<li>The imported data is an object with a <code>default</code> property
that allows you to access the module.</li>
</ul>
</details>
</section>
<!-- A Simplistic Game -->
<section id="a-simplistic-game" aria-labelledby="a-simplistic-game" data-item="A Simplistic Game">
<h2>
<a href="#a-simplistic-game">A Simplistic Game</a>
</h2>
<p>The <button data-name="anchor-import-placeholder">proof of concept
code in the last section</button> does not create anything interactive.
You can change the content of <code>placeholder.js</code> to what is
shown below, or open the <code>04_import_number_game/</code> subfolder
in your <code>Sandbox/</code> folder, where you will find the same
code.</p>
<h3 id="edited-placeholder.js">Edited placeholder.js</h3>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">export default function renderGame(root) {
  root.innerHTML = ""

  const target = Math.ceil(Math.random() * 5)

  const checkNumber = (event) =&gt; {
    const button = event.target
    if (button.textContent == target) {
      button.style.background = "green"
      button.style.color = "white"
      
    } else {
      button.disabled = true
    }
  }

  const title = document.createElement("h2")
  title.textContent = `Click number ${target}`
  root.append(title)


  for (let i = 1; i &lt;= 5; i++) {
    const button = document.createElement("button")
    button.textContent = i
    button.style.margin = "0.5em"

    button.onclick = checkNumber

    root.append(button)
  }
}</code></pre>
<p>This creates a simple, yet functional game that demonstrates the
basics of user interaction:</p>
<figure>
<img src="images/04-number-game.webp"
alt="Importing an interactive mini-game" />
<figcaption aria-hidden="true">Importing an interactive
mini-game</figcaption>
</figure>
<details class="hint" open>
<summary>
A React version of the same game
</summary>
<p>Compare the plain JavaScript code above to how it would look when
written in JSX for React:</p>
<h3 id="placeholder.jsx">Placeholder.jsx</h3>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">const RenderGame = () =&gt; {

  const target = Math.ceil(Math.random() * 5)

   const checkNumber = (event) =&gt; {
    const button = event.target
    if (button.textContent == target) {
      button.style.background = "green"
      button.style.color = "white"
      
    } else {
      button.disabled = true
    }
  }

  const title = &lt;h2&gt;Click number {target}&lt;/h2&gt;

  const buttons = [1,2,3,4,5].map( number =&gt; (
    &lt;button
      key={number}
      onClick={checkNumber}
      style={{
        margin: "0.5em"
      }}
    &gt;
      {number}
    &lt;/button&gt;
  ))

  return (
    &lt;&gt;
      { title }
      { buttons }   
    &lt;/&gt;
  )
}

ReactDOM
  .createRoot(document.getElementById("root"))
  .render(&lt;RenderGame /&gt;)</code></pre>
<p>You can test this JSX version by launching the
<code>JSindeX.html</code> file that you‚Äôll find in the same
<code>Sandbox/04-import-number-game/</code> folder.</p>
<p>Do you see how the plain vanilla JavaScript performs an identical
function to the JSX code?</p>
<p>Only the line‚Ä¶</p>
<pre class="language-javascript line-numbers" data-start="2"><code class="language-javascript line-numbers">  root.innerHTML = ""</code></pre>
<p>‚Ä¶ has no equivalent in the JSX code, because the JSX code is not
imported.</p>
<h3 id="a-peek-behind-the-curtain">A peek behind the curtain</h3>
<p>The <code>JSindeX.html</code> file uses <code>&lt;script&gt;</code>
tags in the <code>&lt;head&gt;</code> to download the code for React and
ReactDOM from a CDN, and also downloads a Babel standalone that
transpiles the JSX code in <code>Placeholder.jsx</code> to plain
JavaScript directly in the browser.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;JSX Number Game&lt;/title&gt;

  &lt;!-- Load React and ReactDOM from CDN --&gt;
  <b>&lt;script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"&gt;&lt;/script&gt;
  &lt;script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"&gt;&lt;/script&gt;</b>
  &lt;!-- Load Babel standalone to convert JSX to JS --&gt;
  <b>&lt;script src="https://unpkg.com/@babel/standalone@7.21.4/babel.min.js"&gt;&lt;/script&gt;</b>

  &lt;!-- Load the custom script that creates the React components --&gt;
    &lt;script defer <b>type="text/babel"</b> src="./Placeholder.jsx"&gt;&lt;/script&gt;
  
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="root"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p><strong>NOTE: Using the Babel standalone is fine for a quick and
dirty demo, like this one, but it won‚Äôt allow you to use
<code>import</code> in any shape or form. This is why you need to use
<code>esbuild</code> to precompile the JSX code elsewhere in this
tutorial.</strong></p>
</details>
<details class="pivot" open>
<summary>
Summary
</summary>
<p>This section has shown you that plain JavaScript can do everything
that React‚Äôs JSX code can do. Indeed, this should go without saying,
because JSX transpiles down to JavaScript for production.</p>
<p>The way you write code in modular components in React is made
possible by the native JavaScript keyword, <code>import</code>.</p>
<p>In the next section, you‚Äôll see JavaScript versions of the three
mini-language game modules that make up the final React project, which
you already saw as a preview at the beginning.</p>
</details>
</section>
<section id="intro" aria-labelledby="intro" data-item="Introduction">
<h2>
<a href="#intro">A Use Case for Code Splitting</a>
</h2>
<p>Alice teaches French as a foreign language. She has a smartboard in
her classroom, and there are enough tablets for all her students. She
wants to create a number of fun activities, to encourage her students to
practice their new language, and she has a vivid imagination. Ideally,
she wants web app with a single simple URL, to which she (or rather we)
can add new activities from time to time, as her plans crystallize.</p>
<p>To begin with, the app will have a single activity, and it won‚Äôt take
long to load. But over time, the amount of code and assets required for
all the activities that Alice plans will become too much to load all at
once. Why make the end-user wait while the code and assets load for
activities that are not yet needed? Why not load files just in time?</p>
<p>What we need to create is basicly a <em>generic engine</em> whose
possibilities can evolve organically, without us having to rewrite the
core code each time a new activity is added.</p>
<p><strong>Code splitting</strong> seems to be the solution. So that‚Äôs
what this tutorial is about.</p>
<h2 id="sneak-preview">Sneak preview</h2>
<p>In this tutorial, you won‚Äôt be building the powerhouse app that Alice
wants. Your own project has very different requirements.</p>
<p>Instead, you‚Äôll be building an app with three ultra-simple language
games that are loaded on demand. This will be enough for you to master
the necessary techniques. It will be up to you to replace these simple
games with features that you actually need in your own project.</p>
<p>The app that you will create here will look something like this:</p>
<iframe id="iframe-split" title="iframe-split" width="300" height="150" src="https://merncraft.github.io/Lazy-Loading-Project/">
</iframe>
</section>

<div class="spacer"></div>
<footer id="content-footer">
<button type="button" class="previous" disabled>
  <img src="../public/svg/prev.svg" alt="prev" draggable="false">
</button>
<span class="previous-name"></span>
<span class="spacer"></span>
<button type="button" class="next">
  <img src="../public/svg/next.svg" alt="next" draggable="false">
</button>
<span class="next-name"></span>
</footer>
</main>

<nav
id="menu"
aria-labelledby="menu"
class="open"
>
<div class="theme">
  <label
  title="Dark"
  >
  <img src="../public/svg/dark.svg" alt="dark">
  <input
  type="radio"
  name="theme"
  id="theme-dark"
  checked
  >
  </label>
  <label
  title="Light"
  >
  <img src="../public/svg/light.svg" alt="light">
  <input
  type="radio"
  name="theme"
  id="theme-light"
  >
  </label>
  </div>
  <div class="paging">
  <label
  title="Split into sections"
  >
  <img src="../public/svg/pages.svg" alt="pages">
  <input
  type="radio"
  name="paging"
  id="pages"
  checked
  >
  </label>
  <label
  title="Show as a single page"
  >
  <img src="../public/svg/scroll.svg" alt="scroll">
  <input
  type="radio"
  name="paging"
  id="scroll"
  >
  </label>
  </div>
<img src="../public/svg/hamburger.svg" alt="menu" id="menu-icon">

<ul id="menu-items">
</ul>
<div id="repo">
<a
href="https://github.com/MERNCraft/Lazy-Loading/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/Lazy-Loading"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>